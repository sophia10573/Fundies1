; Homework 4 - Liam Knowles and Sophia Thomas 

(require 2htdp/image)
(require 2htdp/universe)

;Exercise 1:
;Design the data necessary to represent a line in mathematics, which has no beginning and no end.
;We will consider two forms: slope-intercept (where we specify two constants, m and b,
;such that y = mx + b)
;and a vertical line (where we specify one constant, which is the x location of the line).

(define-struct lines [M B])

;A Line is one of:
; a (make-line M B)
; vertical line (X)

(define M 2)
(define M2 3)
(define B 1)
(define B2 2)
(define X 3)
(define X2 7)

(define LINE1 (make-lines M B))
(define LINE2 (make-lines M2 B2))
(define LINE3 X2)


(define (make-lines-temp line)
  (...
   (cond
     [(lines? line) (lines-M line)...(lines-B line)... ]
     [(integer? line) line])))


;Exercise 2: Consider the following data definition, inspired by the game Barrel of Monkeys:

#;(define-struct monkey [name c others])
; A MonkeyChain is a (make-monkey String String MonkeyChain)
; and represents a collection of monkeys where:
; - name is the name of this monkey
; - c is the color of this monkey
; - others is the other monkeys it is attached to
; What is the problem with this data definition? Describe your answer in a comment.
;(Hint: try defining examples of a MonkeyChain.)

; The data definition for MonkeyChain contradicts itself because it define MonkeyChain as a
; make-monkey with a parameter of MonkeyChain and the other monkeys it is attached to.



; Exercise 3

(define-struct delay [reason minutes])
; A TrainStatus is one of:
; - Integer
; - String
; - (make-delay String PosInt)
; - false
; and represents number of minutes away, a status message (e.g., "arriving"),
; minutes of delay and reason, or that the train has been cancelled

(define TRAINSTATUS1 4)
(define TRAINSTATUS2 "arriving")
(define TRAINSTATUS3 (make-delay "due to signaling error" 10))
(define TRAINSTATUS4 false)

(define (delay-temp delay)
  (...(delay-reason delay)...(delay-minutes delay)...))

; announce : Number String TrainStatus --> String
; outputs an announcement for the train.

(check-expect (announce 9 "Portland" 1) "Train 9 to Portland is 1 minute away.")
(check-expect (announce 123 "Newark" "arriving") "Train 123 to Newark is arriving.")
(check-expect (announce 82 "Philadelphia" "boarding") "Train 82 to Philadelphia is boarding.")
(check-expect (announce 76 "Chicago" (make-delay "signaling error" 10))
              "Train 76 to Chicago is delayed 10 minutes due to signaling error.")
(check-expect (announce 9348 "Boston" "cancelled") "Train 9348 to Boston is cancelled.")

(define (announce trainnum destination TrainStatus)
  (cond
    [(integer? TrainStatus) (string-append "Train " (number->string trainnum) " to " destination " is "
                                           (number->string TrainStatus) " minute away.")] ; ASK TA IF WE NEED TO MAKE SEPARATE FUNCTION TO DIFFERENTIATE BETWEEN MINUTE AND MINUTES
    [(string? TrainStatus) (string-append "Train " (number->string trainnum) " to " destination " is "
                                          TrainStatus ".")]
    [(delay? TrainStatus) (string-append "Train " (number->string trainnum) " to " destination " is"
                                         " delayed " (number->string (delay-minutes TrainStatus))
                                         " minutes due to "
                                         (delay-reason TrainStatus) ".")]))


; Exercise 4:

(define-struct red [ticks-left])
(define-struct blue [ticks-left])
 
; A ReflexGameState (RGS) is one of:
; - (make-red Nat)
; - (make-blue Nat)
; and represents the current state of the game,
; either red or blue, and how many ticks are left
; to show in that state before switching to the other

(define RGS-1 (make-red 154))
(define RGS-2 (make-blue 14))

(define (red-temp RGS)
  (... (red-ticks-left RGS) ...))

(define (blue-temp RGS)
  (... (blue-ticks-left RGS) ...))


(define-struct game [rgs bool])

; A Game is a (make-game RGS Bool)
; and represents the current state of the game,
; while also giving a boolean representation of whether or not
; a key has been pressed

(define GAME-1 (make-game RGS-1 true))
(define GAME-2 (make-game RGS-2 true))
(define GAME-3 (make-game RGS-2 false))

(define (game-temp g)
  (... (game-rgs g) ...
       (game-bool g) ...)) 

;reflexes : Any -> Boolean
;shows a red screen for 140 ticks and then shows a blue screen for 14 ticks and
;repeats until the user ends the program (by pressing any key).

(define (reflexes g)
  (blue?
   (game-rgs
    (big-bang g
      [to-draw reflex-screens]
      [on-tick change-rgs]
      [on-key key-pressed]
      [stop-when bool-stop]))))

; reflex-screens : RGS -> Image
; creates red and blue screens based on the ReflexGameState
(check-expect (reflex-screens GAME-1) (square 500 "solid" "red"))
(check-expect (reflex-screens GAME-2) (square 500 "solid" "blue"))

(define (reflex-screens g)
  (cond
    [(red? (game-rgs g)) (square 500 "solid" "red")] 
    [(blue? (game-rgs g)) (square 500 "solid" "blue")]))


; change-rgs : TickEvent RGS -> RGS
; Changes the RGS based on the number of ticks. 
(check-expect (change-rgs GAME-1) (red-help GAME-1))
(check-expect (change-rgs GAME-2) (blue-help GAME-2))

(define (change-rgs g)
  (cond 
    [(red? (game-rgs g)) (red-help g)]
    [(blue? (game-rgs g)) (blue-help g)]))
   
   
; blue-help : ReflexGameState -> Game
; changes the ReflexGameState to red if the number of ticks is above or equal 14 and subtracts 1 from
;the ticks
(check-expect (blue-help GAME-2) (make-game (make-blue 13) true))

(define (blue-help g)
  (cond
    [(zero? (blue-ticks-left (game-rgs g))) (make-game (make-red 154) (game-bool g))]
    [(<= (blue-ticks-left (game-rgs g)) 14)
     (make-game (make-blue (sub1 (blue-ticks-left (game-rgs g))))(game-bool g))]))     

; red-help : ReflexGameState -> ReflexGameState
; changes the ReflexGameState to red if the number of ticks is above or equal 14 and subtracts 1 from
;the ticks 
(check-expect (red-help GAME-1) (make-game (make-red 153) true))                            

(define (red-help g)
  (cond
    [(> (red-ticks-left (game-rgs g)) 14) (make-game (make-red (sub1 (red-ticks-left (game-rgs g))))(game-bool g))]
    [(<= (red-ticks-left (game-rgs g)) 14) (make-game (make-blue (sub1 (red-ticks-left (game-rgs g))))(game-bool g))])) 


(define REDEND "red")
(define BLUEEND "blue") 

; key-pressed : Game KeyEvent -> Boolean                                            
; Stops program when any key is pressed, outputs true if ends on blue screen and false if red screen
                                                                                            ;check-expect for key-press?

(define (key-pressed g key)
  (if (key-event? key) (make-game (game-rgs g) (not (game-bool g))) g))

; bool-stop : Game -> Boolean                                            
; Stops program when any key is pressed, outputs true if ends on blue screen and false if red screen
(check-expect (bool-stop GAME-1) false)
(check-expect (bool-stop GAME-2) false)
(define (bool-stop g)
  (boolean=? (game-bool g) false))


; Exercise 5
; A Posn is a (make-posn Number Number)
; and represents a 2D position

;(define POSN-1 (make-posn 3 4))
;(define POSN-2 (make-posn 30 40))
;(define POSN-3 (make-posn 81 17))
;
;(define-struct circ [radius center])
;(define-struct sq [side center])
 
; A Shape is one of...
; - (make-circ PosNumber Posn)
; - (make-sq PosNumber Posn)
; and represents a cirle with a radius and center
; or a square with side length and center

;(define CIRCLE-1 (make-circ 30 POSN-1))
;(define CIRCLE-2 (make-circ 75 POSN-2))
;(define CIRCLE-3 (make-circ 62 POSN-3))
;
;(define (circ-temp circ)
; (... (circ-radius circ) ... (circ-center circ) ...))

;(define SQUARE-1 (make-sq 30 POSN-1))
;(define SQUARE-2 (make-sq 75 POSN-2))
;(define SQUARE-3 (make-sq 62 POSN-3))
;
;(define (sq-temp sq)
; (... (sq-side sq) ... (sq-center sq) ...))







; Exercise 7:
; A planetary system has some number of planets, each with a name, distance from the host star
; (in astronomical units), and some number of moons, each of which has a relative ordering in distance
; from the planet and a mass (in 1016 kg). Design the function bigger-moon?, which determines if any
; planet in a system has a moon whose mass is greater than a supplied value.

(define-struct moon [order mass])

(define MOON-1 (make-moon 1 5000))
(define MOON-2 (make-moon 1 1000))
(define MOON-3 (make-moon 2 3050))

; a List of Moons (LoM) is one of
; - empty
; (cons Moon LoM)
; Intepretation: Represents a list of moons that orbit the same planet

(define LOM-0 empty)
(define LOM-1 (cons MOON-1 LOM-0))
 
(define (moon-temp moon)
  (... (moon-order moon) ...
       (moon-mass moon) ...))


(define-struct planet [name distance moon])

(define PLANET-1 (make-planet "Earth" 960000000 LOM-1))
(define PLANET-2 (make-planet "Mars" 129000000 LOM-1))

(define SYSTEM-0 empty)
(define SYSTEM-1 (cons PLANET-1 SYSTEM-0))
; a List of Planets (LoP) is one of
; - empty
; (cons Planet LoP)
; Intepretation: Represents a list of planets

(define (planet-temp planet)
  (... (planet-name planet) ...
       (planet-distance planet) ...
       (planet-moon planet) ...))



; bigger-moon? : System Mass -> Boolean
; accesses the lists created by planet and moon and checks if they are empty
(check-expect (bigger-moon? SYSTEM-1 6000) false)
(check-expect (bigger-moon? SYSTEM-1 2000) true)

(define (bigger-moon? system num)
  (cond
    [(empty? system) false]
    [(cons? system) (if (list-moons (planet-moon (first system)) num)
                        true (bigger-moon? (rest system) num))]
    ))


; list-moons : List Number -> Boolean
; Checks if the moon mass is greater than the supplied value
(check-expect (list-moons LOM-0 35) false)
(check-expect (list-moons LOM-1 7000) false)
(define (list-moons lom num)
  (cond
    [(empty? lom) false]
    [(cons? lom) (if (> (moon-mass (first lom)) num)
                     true (list-moons (rest lom) num))]))
















